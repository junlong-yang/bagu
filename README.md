# 网络
## TCP和UDP有什么区别
1. TCP是面向连接的，UDP是无连接的。
2. TCP是可靠的，保证数据的正确性，UDP是不可靠的，可能会丢包。
3. TCP是保证有序的，UDP是无序的。
4. TCP的结构比UDP要复杂。

## TCP怎么保证可靠
1. 校验和。由发送端计算待发送 TCP 报文段的校验和，然后接收端对接收到的 TCP 报文段验证其校验和。
2. 序列号和确认应答机制。TCP 报文段的首部中有一个序号字段,接收方收到 TCP 报文段后就会返回一个确认应答消息。
3. 重传机制。包括超时重传和快速重传。在报文段丢失或ACK丢失都会进行超时重传。而每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。
4. 滑动窗口协议。累积确认，发送方的数据保留在缓冲区一段时间，直到收到该报文段的确认应答，或后续报文段的确认应答。发送方和接收方的滑动窗口。
5. 流量控制。根据接收方的缓冲区大小，发送方进行流量控制。
6. 拥塞控制。在出现网络拥塞之后，通过控制拥塞窗口的大小，调节发送方的发送的数据量，以降低网络的拥塞程度。



# 操作系统
## 孤儿进程、僵尸进程、守护进程分别是什么
1. 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害。
2. 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，释放其占用资源，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
3. 守护进程是一种运行在后台的特殊的进程，用于周期性处理某种任务或处理某些特定的事件，对整个系统或某个用户程序提供服务。守护进程的父进程在fork之后就先退出了，因此守护进程也是孤儿进程。



# JAVA
## 什么是死锁，JAVA里面的死锁是怎么产生的，如何预防和避免死锁
1. 死锁是两个或多个线程由于竞争资源、相互等待而永远被阻塞的情况。
2. 死锁的必要条件:  
    a. 互斥：资源必须是非共享的，即一个进程占用了该资源，那么另外一个进程只能在该资源被释放之后再申请。  
    b. 占有并等待：—个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。  
    c. 非抢占：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。  
    d. 循环等待。  
3. 预防死锁的办法：  
    a. 破坏占有并等待条件：进程在运行开始前申请需要的所有资源，但是可能会因资源不满足而无法启动。  
    b. 破坏不可抢占条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。  
    c. 破坏循环等待条件：将资源编号，并且必须按照一定的顺序进行申请。  
4. 避免死锁的办法：利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。

## ArrayList的扩容机制
ArrayList是的初始容量为10，在向ArrayList中添加元素时，如果元素个数超过了当前容量，则会自动进行扩容。ArrayList的扩容机制如下：  
1. 当元素个数size达到容量capacity时，ArrayList会将当前容量扩大为原来的1.5倍。
2. 新建一个大容量的数组，并将原数组中的元素全部复制到新数组中，再将新元素添加到新数组末尾。
3. 将新数组设置为ArrayList的内部数组，原数组被垃圾回收。

## 线程安全的集合有哪些
1. ConcurrentHashMap：线程安全且效率高的哈希表实现，实现了Map接口。
2. CopyOnWriteArrayList：线程安全的ArrayList，它在写入操作时会复制一份原来的数据，并在复制的数据上进行修改，从而避免并发冲突。
3. CopyOnWriteArraySet：线程安全的Set，它在写入操作时会复制一份原来的数据，并在复制的数据上进行修改，从而避免并发冲突。
4. ConcurrentLinkedDeque：线程安全的队列实现，实现了Deque接口。
5. ConcurrentLinkedQueue：线程安全的队列实现，实现了Queue接口。
6. ConcurrentSkipListMap：线程安全且有序的Map实现，基于跳表数据结构实现。
7. ConcurrentSkipListSet：线程安全且有序的Set实现，基于跳表数据结构实现。
8. 除了以上这些线程安全的集合类之外，也可以通过Collections类的synchronized方法将原生集合转换为线程安全的集合。例如：synchronizedList和synchronizedSet。

## CopyOnWriteArrayList了解多少
CopyOnWriteArrayList 是一个线程安全的 List 集合，它采用的是一种读写分离的策略，通过写时复制（Copy-On-Write）来实现并发访问的。在每次写操作时，都创建一个新的数组，从而实现并发的写操作，而读操作不需要锁定，因为不会发生数据的修改，最后再将修改后的新数据替换原始数据。  
因为 CopyOnWriteArrayList 的实现是通过复制原有数组的方式，因此有较高的空间复杂度，因此适用于读远多于写的场景。同时，它也不适用于实时性要求高的场景，因为写操作的延迟比较大。  
需要注意的是，虽然 CopyOnWriteArrayList 是线程安全的，但是它并不保证元素的实时性和同步性，因此在对集合元素的修改和访问中，需要关注线程安全问题。

## List的快速失败(fail-fast)和安全失败(fail-safe)了解多少
List 的快速失败（fail-fast）和安全失败（fail-safe）都是针对多线程并发访问的问题。  
快速失败是指在集合发生并发修改时，通过抛出“并发修改异常”来提醒其它线程停止对集合进行访问和修改，以避免数据不一致的问题。ArrayList 和 LinkedList 等集合都是快速失败的实现。  
相反，安全失败是指在集合发生并发修改时，不会抛出异常，而是集合会对当前进行操作的那一份数据持有副本，并以这份副本为基础进行修改操作，而其他线程读取到的是之前的旧数据，这就是所谓的安全失败。这样，即使其它线程进行了修改操作，也不会影响到当前操作的对象。例如，CopyOnWriteArrayList 就是一种线程安全的集合，它的遍历操作是安全失败的实现。

## 谈一下HashMap的数据结构
HashMap用于存储键值对。HashMap的底层数据结构是数组和链表（在新版Java中加入了红黑树），当链表的长度超过8之后，会转换为红黑树，低于这个数会转换为链表。  
当一个键（key）被插入HashMap时，它被哈希（hash）为一个整数，并且被映射到数组索引上。如果在该索引处已经有一个键值对存在了，那么这个新的键值对将通过链表或红黑树添加到该位置。如果索引处没有其他键值对存在，则插入直接完成。  
当获取键对应的值时，HashMap也是将键哈希为一个整数，并使用该整数查找对应的数组索引，如果索引处存在键值对，则通过链表或红黑树查找该键的值。如果没有发现键，就返回null。

## HashMap的hash函数是怎么设计的
1. 将key的hashcode与它自己无符号右移 16 位（即 >>> 16）后的值进行异或。  
2. 将上一步中得到的值与hash表的长度取模，计算出index。  
3. 通过这样的哈希函数设计，既考虑了哈希码值的高位和低位，又充分利用了异或操作和取模运算的高效性，从而使得在分布散列场景下，HashMap 能够更加均衡地将元素分布到各个桶中，以此来提高查询效率。

## 为什么hash表的容量是2的倍数
1. 因为计算桶号的公式为 hash & (length - 1)，这时 length - 1 用二进制表示为 n 个 1，只让hash的低位参与运算，将会有更高的效率。  
2. 方便在扩容的时候，重新散列的数据和原来所在的桶有一定的规律。

## 解决hash冲突的方法有哪些
1. 使用链表。
2. 在当前冲突的位置，通过线性探测、二次探测函数，找到下一个空的桶。
3. 再哈希，使用不同的hash函数重新进行hash。

## 为什么hashmap链表转红黑树的阈值为8
1. 时间复杂度考虑：当哈希表中链表长度达到一定的长度时，继续使用链表会导致时间复杂度的线性增长。使用红黑树，当树的高度为n时，只需要n+3左右的操作即可完成插入。对于8个节点，3-4层的红黑树而言，使用链表和红黑树的性能相当，但随着节点增多，使用红黑树的效率将明显提高。
2. 空间占用考虑：红黑树会占用更多额外的内存，当节点较少时，插入的性能与链表相当，但会消耗更多的内存。

## hashmap的扩容机制
当hashmap的容量超过例如75%时会发生扩容：  
1. 创建一个新的数组，其大小是原数组的两倍。
2. 将原数组中的元素重新分配到新数组中。
3. 将新数组设置为HashMap中的数组。这样，HashMap现在使用的就是新数组。原数组将被垃圾回收机制回收，释放在原数组中使用的空间。

## HashMap在多线程的情况下会有什么问题
数据丢失：在HashMap的put操作中，如果两个线程同时调用put方法，可能会导致数据的覆盖，出现数据丢失的问题。

## HashMap和HashTable有什么区别
1. 线程安全性：Hashtable 是线程安全的，而 HashMap 的线程安全要靠在多线程环境下合理的同步方式来保证，否则会存在并发问题。
2. 空值（null）处理：Hashtable 中不允许出现 null 键和 null 值，如果试图添加一个 null 键或值，将会抛出 NullPointerException 异常；而 HashMap 中则可以存储一个 null 键和多个 null 值。
3. 初始容量和扩容方式：Hashtable 的初始容量为 11，负载因子为 0.75。HashMap 的默认初始容量为 16，负载因子为 0.75。在数据量增长的过程中，二者扩容方式也不同，Hashtable 每次扩容通常增大到原来容量的两倍，而 HashMap 每次扩容通常增大到原来容量的两倍，并将容量扩大到大于所需的容量的最小2的幂次。

## 从分段锁和CAS的角度说一下ConcurrentHashMap的实现
1. 分段锁  
    ConcurrentHashMap将整个哈希表分成了多个子段，每个子段都拥有自己的锁Segment，这样在进行操作时，只需要获得该子段的锁，而不需要对整个哈希表进行加锁，从而提高了并发性能。
2. CAS  
    当多个线程需要更新同一个位置的数据时，可以使用CAS来判断该位置的数据是否已经被其他线程修改，如果没有被修改，则可以更新该位置的数据；如果被修改了，则会失败并重新尝试。  
    具体来说，通过使用CAS操作比较当前bucket的value字段的值是否和期望的值相等，如果相等则表示该位置的数据没有被其他线程修改，即可以进行修改操作，这是一个原子操作。



# JVM
## 请说一下JVM的内存区域
1. 程序计数器（Program Counter Register）：用于指示当前线程执行的字节码指令的地址，是线程私有的。
2. Java虚拟机栈（Java Virtual Machine Stacks）：每个Java方法在执行时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是线程私有的。
3. 本地方法栈（Native Method Stack）：与Java虚拟机栈类似，但是用于执行本地方法（Native Method）。
4. Java堆（Java Heap）：用于存储对象实例、数组等信息，是所有线程共享的内存区域。
5. 方法区（Method Area）：即永久代，用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在JDK1.8中，这个区域被称为“元空间”。
6. 直接内存（Direct Memory）：不受JVM限制的内存区域，通常与Java NIO（New I/O）有关，由ByteBuffer来操作。

### JDK1.6中的内存区域
1. 堆（Heap）  
堆是用于存储Java对象实例的内存区域。在JDK1.6中，堆分为Young区、Old区和Permanent区（永久代）。Young区又分为Eden区、Survivor0区和Survivor1区。对象在Eden区被创建，在Survivor区间中进行存活时间短的存活，最终进入Old区。而Permanent区存储的是Java类的元数据信息。
2. 非堆（Non-heap）  
JDK1.6中的非堆主要由Method Area和Java虚拟机栈组成。Method Area存储Java类的元数据信息，如类信息、方法信息和接口信息。Java虚拟机栈用于存储方法的调用和执行信息。

### JDK1.7中的内存区域
1. 堆（Heap）  
在JDK1.7中，堆同样分为Young区和Old区，Young区进一步细化为Eden区、Survivor0区和Survivor1区。在JDK1.7中，对于持久代（Permanent Generation）的处理有所不同。JDK1.7将持久代移动到了Native内存区域，即与Java Heap不同的内存区域。
2. Non-heap  
在JDK1.7中，非堆主要由Java虚拟机栈和程序计数器组成。Java虚拟机栈和JDK1.6的一样，用于存储方法的调用和执行信息，而程序计数器用于记录当前线程执行的位置。

### JDK1.8中的内存区域
1. Heap  
在JDK1.8中，堆同样分为Young区和Old区，同时加入了元空间（Metaspace）。元空间之所以被加入，是由于永久代（PermGen）已经被移除了。在JDK1.8中，元空间直接使用本机内存，取代了JDK1.7中的持久代。
2. Non-heap  
在JDK1.8中，非堆主要由Java虚拟机栈和程序计数器组成，与JDK1.7相同。

## JDK1.8里面，为什么使用元空间替代永久代作为方法区的实现
1. 永久代的大小无法调整，可能会出现OOM。元空间使用本地内存，容量可以根据初始容量、最大容量、闲置最小比例、闲置最大比例来动态调整元空间大小。
2. 永久的的垃圾回收基于标记清除算法，垃圾回收过程非常复杂，可能会频繁Full GC。元空间垃圾回收时，可以使用 G1 GC 算法进行优化，因为 G1 算法已经被用于管理堆内存，因此使用相同的算法来管理元空间更高效。

##  Java堆具体是怎么分区的
1. 年轻代：分为一个Eden区和两个Survivor区。大部分新对象都会被分配到Eden区。当Eden区满时，这些对象中的一部分会被移动到Survivor区（其中一个为From区，一个为To区），这些对象经过一段时间后如果仍然存活，则会被移动到老年代中。
2. 老年代：存储一些年龄比较大的对象，这些对象由于生命周期比较长，不容易被垃圾回收器回收。

## Young GC和Full GC分别什么情况下触发
### Young GC 触发的情况：
1. Eden 区域内存不足时，会触发 Young GC 进行内存清理，通常会把 Eden 区中存活的对象复制到 Survivor 区中。
2. Survivor 区内存不足时，也会触发 Young GC。当其中一个 Survivor 区被占满时，触发 Young GC，并把存活的对象复制到另一个Survivor区。目的是回收内存碎片。
### Full GC触发的情况：
1. Old 区空间不足，无法为新对象分配内存，此时会进行 Full GC。
2. 过多的空间碎片导致系统无法找到足够的连续内存空间，从而触发 Full GC 进行内存整理和回收。

## Java 中可以作为GC Roots的对象有哪几种
有些对象被视为 GC Roots，因为它们无法通过其他对象到达。垃圾回收器从这些对象开始跟踪并标记所有可达对象，剩下的就是无法访问的对象，即垃圾，然后清理并回收它们的空间。  
1. 虚拟机栈中的引用对象，包括局部变量和参数等。
2. 方法区中的静态变量和常量引用对象。
3. 其他基本类型（integer，long，float，double等）和系统类对象，如系统类加载器，方法集等。

## 什么是Stop The World
“Stop The World”（STW）是一个垃圾回收器的行为概念，即在垃圾回收器执行垃圾回收操作期间暂停了应用程序所有的线程，以便进行垃圾回收操作。在这段时间内，应用程序无法进行任何操作，包括响应用户请求，导致应用程序出现暂停。  
这种行为通常出现在年轻代垃圾回收、Full GC以及CMS收集器的垃圾回收阶段。由于STW的存在，当应用需要进行大量垃圾回收操作时，应用的性能将会受到影响，因为应用程序需要等待垃圾回收器完成其操作，才能继续进行下一步操作。

## 对象什么时候会进入老年代
1. 对象在Eden和Survivor区经历了一定次数的垃圾回收后，会被移动到老年代，这个阈值默认是15。
2. 无法在新生代分配合适内存的大对象在创建的时候，就被放入老年代。

## 垃圾收集算法有哪些
1. 标记-清除算法 (Mark-Sweep)：首先标记所有活动对象，然后清除未标记对象，存在碎片问题。
2. 复制算法 (Copying)：将内存分成两块，每次只使用其中一块，当使用完后，将还存活的对象复制到另一块内存中，然后清除整块内存，不存在碎片问题，但需要额外的空间来复制对象。
3. 标记-压缩算法 (Mark-Compact)：标记所有活动对象，然后将它们移到内存的一端，然后清除端之外的所有对象，现代JVM的默认收集算法之一。
4. 分代收集算法 (Generational)：根据对象的年龄将堆划分为不同的区域，一般是年轻代和老年代，两个区域使用不同的垃圾收集算法，适应不同对象的生命周期特点。常用的有Parallel Scavenge算法和CMS算法。

## 垃圾收集器有哪些，都基于什么算法，适用于什么场景。
1. Serial收集器：是最基础和最古老的收集器，采用复制算法，只会使用一个线程进行垃圾回收，适合小型的应用场景。
2. CMS收集器：是JVM中最初采用的一种并发垃圾收集器，采用了标记-清除算法，主要对老年代进行垃圾回收，目标明确、收集范围小，并且不整理内存空间，因此收集时间较短。适用于响应速度较高的应用场景。
3. Parallel收集器：基于复制算法和标记-压缩算法，采用多线程并行收集，适用于大数据量、高并发应用程序，并且可以使用多核处理器的优势，提供更高的吞吐量。
4. G1收集器：基于分区的算法，可以将堆内存划分为多个小堆区域进行垃圾回收，从而减少单次垃圾回收的时间，并且能够处理内存碎片化的问题。适用于大堆（4GB）应用场景。

## 简单说一下CMS收集器的垃圾收集过程
1. 初始标记阶段：停止所有应用线程，执行短暂的暂停操作。在这个阶段，只标记与GC Roots相关的对象，完成后继续执行应用程序。
2. 并发标记阶段：在应用程序继续运行的同时，开始对所有剩余对象进行标记。符合条件的对象标记完成，不符合条件的对象被放入回收集。
3. 重新标记阶段：当并发标记阶段结束后，暂停应用程序，执行一次短暂的重新标记操作，以便标记在并发标记阶段期间新创建或修改的对象。
4. 并发清除阶段：并发清除阶段开始时，将所有未被标记的对象（即垃圾）放入回收集，并在完成时释放相应的空间。此操作是与应用程序同时进行的。

## 有了CMS收集器，为什么还要引入G1收集器
1. G1垃圾收集器可以避免内存碎片的发生，因此垃圾回收结束后空闲的内存空间都是连续的，移除了大量的碎片空间重新合并的过程。
2. G1垃圾收集器可以控制停顿时间。CMS垃圾收集器有可能因为在回收时出现多次用户线程进入STW状态的情况，导致长时间暂停。而G1垃圾收集器设置了最大暂停时间，并能够在不超过停顿时间限制的情况下完成垃圾回收。
3. G1垃圾收集器与CMS垃圾收集器一样，也是一种并发垃圾收集器，但采用了多线程执行并行阶段，从而减少了单线程的执行时间。
4. G1垃圾收集器内部采用了Region对内存进行划分，并可以使用不同的垃圾收集策略，而CMS垃圾收集器仍然是采用以Eden区、Survivor区、老年代三个代进行内存划分，而G1垃圾收集器中划分的更加细致，使硬件资源得到了更加均衡的利用，因此可以表现出更好的吞吐率。

## G1收集器的Region是什么概念，还存在年轻代和老年代的说法吗
在使用G1垃圾收集器时，仍然存在“年轻代”和“老年代”的概念。但是，与传统的垃圾收集器（如CMS）不同的是，G1将堆空间划分为多个大小相等的区域（Region），每个区域都可能被定义为年轻代或老年代。当垃圾收集器运行时，G1会选择垃圾最多的区域进行垃圾回收，并将该区域中存活的对象复制到其他空闲区域中，以回收该区域的空间，而不是像传统的年轻代和老年代的垃圾收集器一样只对年轻代或老年代进行垃圾回收。因此，G1垃圾收集器被认为是一种基于区域的垃圾收集器，它仍然将堆空间逻辑上分为年轻代和老年代，但更注重区域之间垃圾分布的平衡。

## 什么是指针碰撞？什么是空闲列表？
当一个程序需要动态地分配内存空间时，可以使用指针碰撞技术或者空闲列表技术来管理内存。两者的主要区别在于如何跟踪内存块的空闲情况。
1. 指针碰撞技术使用指针来跟踪内存块，当需要分配内存时，从当前指针指向的内存位置开始往上分配；当需要释放内存时，指针往下移动，释放空闲内存块。指针碰撞技术仅适用于内存分配连续的情况下，不适用于非连续内存分配的情况。
2. 空闲列表技术维护一个空闲内存块的链表，每当需要分配内存时，就在该链表上查找可用内存块，然后从中取出一块分配给程序使用。而当程序释放内存时，就将释放的内存块加入到空闲内存块的链表中，以备将来再次使用。



# 多线程
## 并发和并行有什么区别
1. 并发是指两个或多个线程在一段时间内不断地进行交替执行，在逻辑上是同时执行的状态，但在物理上不可能同时运行。
2. 并行是指在同一时刻，多个处理器或多核处理器场景下，多个线程会同时执行不同的任务。



# 数据结构
## 谈谈满二叉树、完全二叉树、二叉查找树、平衡二叉树和红黑树
1. 满二叉树：二叉树的每一层的几点都达到最大值。
2. 完全二叉树：完全二叉树由满二叉树转化而来，也就是将满二叉树从最后一个节点开始删除，一个一个从后往前删除，剩下的就是完全二叉树。
3. 二叉查找树：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大。
4. 平衡二叉树：基于二叉查找树，左右子树的高度之差不大于 1。
5. 红黑树：红黑树有四条性质  
    a. 节点是红色或黑色。  
    b. 根节点是黑色。 
    c. 所有的叶子节点（NIL节点）都是黑色。  
    d. 每个红色节点的两个子节点都是黑色。  
    e. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## 平衡二叉树和红黑树的区别
1. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

## 谈谈红黑树的实现
红黑树的插入：  
1. 将新插入的节点 X 标记为红色
2. 如果 X 是根结点(root)，则标记为黑色
3. 如果 X 的 parent 不是黑色，同时 X 也不是 root  
    - 3.1 如果 X 的 uncle (叔叔) 是红色  
        - 3.1.1 将 parent 和 uncle 标记为黑色  
        - 3.1.2 将 grand parent (祖父) 标记为红色  
        - 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3  
    - 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理  
        - 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) => 旋转 -> 变色  
        - 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) => 旋转 -> 旋转 -> 变色  
        - 3.2.3 右右 (和 3.2.1 镜像过来，恰好相反) => 旋转 -> 变色  
        - 3.2.4 右左 (和 3.2.2 镜像过来，恰好相反) => 旋转 -> 旋转 -> 变色  



# 数据库
## undolog redolog binlog分别是什么
Mysql分为Server层和引擎层。
1. redo log：  
    redo log是执行引擎Innodb的日志，记录了磁盘上的某个位置，应该做什么样的修改。  
    如果每个update语句都要去操作磁盘，那么整个过程的IO成本、查找成本会很高。因此先更新内存，并写入redo log，并在适当的时候再更新磁盘。  
    redo log是有大小限制的，如果redo log满了，需要等待记录擦除后才能再进行更新操作。  
    redo log提供了故障恢复能力，redo log的prepare-commit两段提交，保证了和bin log的一致性。  
2. bin log：  
    bin log是Server成的日志，记录了原始的sql语句。  
3. undo log：  
    用于记录修改前的值，可以用undo log对数据进行回滚。



# C++
## 什么是虚函数，什么是纯虚函数
1. 基类定义一个虚函数，是为了能在子类重写了这个函数之后，能够调用子类的这个函数，实现多态。
2. 定义一个函数为纯虚函数，代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
3. 含有一个或多个纯虚函数的类是抽象类，不能实例化。
