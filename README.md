# 网络
## TCP和UDP有什么区别
1. TCP是面向连接的，UDP是无连接的。
2. TCP是可靠的，保证数据的正确性，UDP是不可靠的，可能会丢包。
3. TCP是保证有序的，UDP是无序的。
4. TCP的结构比UDP要复杂。

## TCP怎么保证可靠
1. 校验和。由发送端计算待发送 TCP 报文段的校验和，然后接收端对接收到的 TCP 报文段验证其校验和。
2. 序列号和确认应答机制。TCP 报文段的首部中有一个序号字段,接收方收到 TCP 报文段后就会返回一个确认应答消息。
3. 重传机制。包括超时重传和快速重传。在报文段丢失或ACK丢失都会进行超时重传。而每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。
4. 滑动窗口协议。累积确认，发送方的数据保留在缓冲区一段时间，直到收到该报文段的确认应答，或后续报文段的确认应答。发送方和接收方的滑动窗口。
5. 流量控制。根据接收方的缓冲区大小，发送方进行流量控制。
6. 拥塞控制。在出现网络拥塞之后，通过控制拥塞窗口的大小，调节发送方的发送的数据量，以降低网络的拥塞程度。



# 操作系统
## 孤儿进程、僵尸进程、守护进程分别是什么
1. 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害。
2. 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，释放其占用资源，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
3. 守护进程是一种运行在后台的特殊的进程，用于周期性处理某种任务或处理某些特定的事件，对整个系统或某个用户程序提供服务。守护进程的父进程在fork之后就先退出了，因此守护进程也是孤儿进程。



# JAVA
## 什么是死锁，JAVA里面的死锁是怎么产生的，如何预防和避免死锁
1. 死锁是两个或多个线程由于竞争资源、相互等待而永远被阻塞的情况。
2. 死锁的必要条件:  
    a. 互斥：资源必须是非共享的，即一个进程占用了该资源，那么另外一个进程只能在该资源被释放之后再申请。  
    b. 占有并等待：—个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。  
    c. 非抢占：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。  
    d. 循环等待。  
3. 预防死锁的办法：  
    a. 破坏占有并等待条件：进程在运行开始前申请需要的所有资源，但是可能会因资源不满足而无法启动。  
    b. 破坏不可抢占条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。  
    c. 破坏循环等待条件：将资源编号，并且必须按照一定的顺序进行申请。  
4. 避免死锁的办法：利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。

## ArrayList的扩容机制
ArrayList是的初始容量为10，在向ArrayList中添加元素时，如果元素个数超过了当前容量，则会自动进行扩容。ArrayList的扩容机制如下：  
1. 当元素个数size达到容量capacity时，ArrayList会将当前容量扩大为原来的1.5倍。
2. 新建一个大容量的数组，并将原数组中的元素全部复制到新数组中，再将新元素添加到新数组末尾。
3. 将新数组设置为ArrayList的内部数组，原数组被垃圾回收。

## 线程安全的集合有哪些
1. ConcurrentHashMap：线程安全且效率高的哈希表实现，实现了Map接口。
2. CopyOnWriteArrayList：线程安全的ArrayList，它在写入操作时会复制一份原来的数据，并在复制的数据上进行修改，从而避免并发冲突。
3. CopyOnWriteArraySet：线程安全的Set，它在写入操作时会复制一份原来的数据，并在复制的数据上进行修改，从而避免并发冲突。
4. ConcurrentLinkedDeque：线程安全的队列实现，实现了Deque接口。
5. ConcurrentLinkedQueue：线程安全的队列实现，实现了Queue接口。
6. ConcurrentSkipListMap：线程安全且有序的Map实现，基于跳表数据结构实现。
7. ConcurrentSkipListSet：线程安全且有序的Set实现，基于跳表数据结构实现。
8. 除了以上这些线程安全的集合类之外，也可以通过Collections类的synchronized方法将原生集合转换为线程安全的集合。例如：synchronizedList和synchronizedSet。

## CopyOnWriteArrayList了解多少
CopyOnWriteArrayList 是一个线程安全的 List 集合，它采用的是一种读写分离的策略，通过写时复制（Copy-On-Write）来实现并发访问的。在每次写操作时，都创建一个新的数组，从而实现并发的写操作，而读操作不需要锁定，因为不会发生数据的修改，最后再将修改后的新数据替换原始数据。  
因为 CopyOnWriteArrayList 的实现是通过复制原有数组的方式，因此有较高的空间复杂度，因此适用于读远多于写的场景。同时，它也不适用于实时性要求高的场景，因为写操作的延迟比较大。  
需要注意的是，虽然 CopyOnWriteArrayList 是线程安全的，但是它并不保证元素的实时性和同步性，因此在对集合元素的修改和访问中，需要关注线程安全问题。

## List的快速失败(fail-fast)和安全失败(fail-safe)了解多少
List 的快速失败（fail-fast）和安全失败（fail-safe）都是针对多线程并发访问的问题。  
快速失败是指在集合发生并发修改时，通过抛出“并发修改异常”来提醒其它线程停止对集合进行访问和修改，以避免数据不一致的问题。ArrayList 和 LinkedList 等集合都是快速失败的实现。  
相反，安全失败是指在集合发生并发修改时，不会抛出异常，而是集合会对当前进行操作的那一份数据持有副本，并以这份副本为基础进行修改操作，而其他线程读取到的是之前的旧数据，这就是所谓的安全失败。这样，即使其它线程进行了修改操作，也不会影响到当前操作的对象。例如，CopyOnWriteArrayList 就是一种线程安全的集合，它的遍历操作是安全失败的实现。

## 谈一下HashMap的数据结构
HashMap用于存储键值对。HashMap的底层数据结构是数组和链表（在新版Java中加入了红黑树），当链表的长度超过8之后，会转换为红黑树，低于这个数会转换为链表。  
当一个键（key）被插入HashMap时，它被哈希（hash）为一个整数，并且被映射到数组索引上。如果在该索引处已经有一个键值对存在了，那么这个新的键值对将通过链表或红黑树添加到该位置。如果索引处没有其他键值对存在，则插入直接完成。  
当获取键对应的值时，HashMap也是将键哈希为一个整数，并使用该整数查找对应的数组索引，如果索引处存在键值对，则通过链表或红黑树查找该键的值。如果没有发现键，就返回null。

## HashMap的hash函数是怎么设计的
1. 将key的hashcode与它自己无符号右移 16 位（即 >>> 16）后的值进行异或。  
2. 将上一步中得到的值与hash表的长度取模，计算出index。  
3. 通过这样的哈希函数设计，既考虑了哈希码值的高位和低位，又充分利用了异或操作和取模运算的高效性，从而使得在分布散列场景下，HashMap 能够更加均衡地将元素分布到各个桶中，以此来提高查询效率。

## 为什么hash表的容量是2的倍数
1. 使用hash % length这样的除法做取模运算的效率很低，而采用 hash & (length - 1) 的方式进行取模运算的效率更高。 
2. 当length为2的倍数是，length - 1为 n 个 1，在做hash的时候将会考虑到hashcode的整个低位，能有效的减少冲突，并且这时的结果与使用%一致。
3. 方便在扩容的时候，重新散列的数据和原来所在的桶有一定的规律。

## 解决hash冲突的方法有哪些
1. 使用链表。
2. 在当前冲突的位置，通过线性探测、二次探测函数，找到下一个空的桶。
3. 再哈希，使用不同的hash函数重新进行hash。

## 为什么hashmap链表转红黑树的阈值为8
1. 时间复杂度考虑：当哈希表中链表长度达到一定的长度时，继续使用链表会导致时间复杂度的线性增长。使用红黑树，当树的高度为n时，只需要n+3左右的操作即可完成插入。对于8个节点，3-4层的红黑树而言，使用链表和红黑树的性能相当，但随着节点增多，使用红黑树的效率将明显提高。
2. 空间占用考虑：红黑树会占用更多额外的内存，当节点较少时，插入的性能与链表相当，但会消耗更多的内存。

## hashmap的扩容机制
当hashmap的容量超过例如75%时会发生扩容：  
1. 创建一个新的数组，其大小是原数组的两倍。
2. 将原数组中的元素重新分配到新数组中。
3. 将新数组设置为HashMap中的数组。这样，HashMap现在使用的就是新数组。原数组将被垃圾回收机制回收，释放在原数组中使用的空间。

## HashMap在多线程的情况下会有什么问题
数据丢失：在HashMap的put操作中，如果两个线程同时调用put方法，可能会导致数据的覆盖，出现数据丢失的问题。

## HashMap和HashTable有什么区别
1. 线程安全性：Hashtable 是线程安全的，而 HashMap 的线程安全要靠在多线程环境下合理的同步方式来保证，否则会存在并发问题。
2. 空值（null）处理：Hashtable 中不允许出现 null 键和 null 值，如果试图添加一个 null 键或值，将会抛出 NullPointerException 异常；而 HashMap 中则可以存储一个 null 键和多个 null 值。
3. 初始容量和扩容方式：Hashtable 的初始容量为 11，负载因子为 0.75。HashMap 的默认初始容量为 16，负载因子为 0.75。在数据量增长的过程中，二者扩容方式也不同，Hashtable 每次扩容通常增大到原来容量的两倍，而 HashMap 每次扩容通常增大到原来容量的两倍，并将容量扩大到大于所需的容量的最小2的幂次。

## 从分段锁和CAS的角度说一下ConcurrentHashMap的实现
1. 分段锁  
    ConcurrentHashMap将整个哈希表分成了多个子段，每个子段都拥有自己的锁Segment，这样在进行操作时，只需要获得该子段的锁，而不需要对整个哈希表进行加锁，从而提高了并发性能。
2. CAS  
    当多个线程需要更新同一个位置的数据时，可以使用CAS来判断该位置的数据是否已经被其他线程修改，如果没有被修改，则可以更新该位置的数据；如果被修改了，则会失败并重新尝试。  
    具体来说，通过使用CAS操作比较当前bucket的value字段的值是否和期望的值相等，如果相等则表示该位置的数据没有被其他线程修改，即可以进行修改操作，这是一个原子操作。



# JVM
## Java对象的创建步骤
1. 在进行对象创建前，JVM会检查该对象所属的类是否已经被加载到内存中。如果没有被加载，JVM会根据类的完整限定名（包名+类名）在磁盘上查找该类的字节码文件，并读取该文件内容到内存中进行解析、装载。
2. 验证类：在类被装载后，JVM会对该类的字节码进行验证，目的是保证字节码的正确性和安全性。验证包括检查字节码格式、语义、安全等方面。
3. 分配内存：JVM会尝试为该类分配一块连续的内存空间，用来存储这个对象的实例变量数据。并为对象实例变量赋初始值。这里所说的赋初始值是指分配内存时，JVM会为对象的各个实例变量分配一块内存空间，并会根据变量类型赋予相应的默认值。例如，对于整型变量，JVM会为其分配4个字节的内存空间，并把这个区域内的所有比特位都设为0。
4. 执行构造方法：JVM会调用类的构造方法来执行对象的初始化。如果没有明确定义构造方法，则会调用默认的构造方法。在构造方法执行完成后，对象就被创建并可以被使用了。
5. JVM返回对象的引用给程序员，程序员可以使用这个引用来访问和操作该对象。

## JVM里new对象的时候，堆会发生抢占吗
JVM在进行对象的分配时，如果有多个线程同时请求分配内存，JVM会通过线程安全的方式保证对象在堆中的正确分配。具体来说，JVM采用的是指针碰撞和空闲列表两种方式进行内存的分配，以及CAS（Compare-And-Swap）等算法保证了线程安全，避免了内存的抢占。因此，在JVM中new对象的时候，堆不会发生抢占。

## 什么是指针碰撞？什么是空闲列表？
当一个程序需要动态地分配内存空间时，可以使用指针碰撞技术或者空闲列表技术来管理内存。两者的主要区别在于如何跟踪内存块的空闲情况。
1. 指针碰撞技术使用指针来跟踪内存块，当需要分配内存时，从当前指针指向的内存位置开始往上分配；当需要释放内存时，指针往下移动，释放空闲内存块。指针碰撞技术仅适用于内存分配连续的情况下，不适用于非连续内存分配的情况。
2. 空闲列表技术维护一个空闲内存块的链表，每当需要分配内存时，就在该链表上查找可用内存块，然后从中取出一块分配给程序使用。而当程序释放内存时，就将释放的内存块加入到空闲内存块的链表中，以备将来再次使用。

## 对象的内存布局
当Java程序创建对象时，JVM会在堆上为该对象分配一块连续的内存，这块内存可以被划分成三部分：对象头、实例数据和对齐填充。
1. 对象头：用于存储一些对象的运行时数据，每个对象头占用的空间为8个字节，存储了例如对象是否可达的标记、锁信息、指向类元数据信息的指针等。
2. 实例数据：它是对象的主要数据，包含了对象的所有非静态属性值，按照从父类到子类的顺序，按照属性在类里定义的顺序，如果是一个基本数据类型，就按照数据的大小分配空间，如果是一个引用类型就分配一个指针大小的空间来存放引用地址，指向具体的对象的实例。
3. 对齐填充：为了保证对象在内存中的地址是8字节的整数倍，在实例数据结束后，可能需要插入一些填充数据来对齐。

## 对象怎么访问定位
1. 将 Java 程序中获取到的对象引用压入 Java 虚拟机栈。
2. 从对象头中获取类型指针，它指向对象所属类的元数据信息的指针，并将该指针存放在寄存器中。
3. 使用类型指针找到对象所属类的元数据信息，即类对象（Class Object）。
4. 从类对象中获取对象变量偏移量，即需要访问的实例变量在对象内存布局中的位置。
5. 根据对象的起始地址和实例变量的偏移量定位到具体的实例变量所在的内存地址，然后操作这个内存地址。

## 请说一下JVM的内存区域
1. 程序计数器（Program Counter Register）：用于指示当前线程执行的字节码指令的地址，是线程私有的。
2. Java虚拟机栈（Java Virtual Machine Stacks）：每个虚拟机栈的生命周期都与一个线程相同，虚拟机栈是线程用来执行方法的内存区域，后进先出，一个线程在执行方法时，每调用一个方法，就是将该方法作为栈帧压入自己的虚拟机栈；方法里调用另一个方法，就是将另一个方法的栈帧再压入虚拟机栈；线程当前执行的方法就是栈顶帧。每一个栈帧对应一个方法。栈帧存储了局部变量表、操作栈、动态连接、方法返回地址。  
    - 局部变量表：对应方法参数与局部变量，其类型是Java的8种基本数据类型加上对象引用。注意是对象的引用，不是对象本身。
    - 操作栈：线程执行方法内部字节码操作指令时使用的后入先出栈，各种指令会往操作栈中写入和提取信息。Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”,里面的“栈”就是操作栈。操作数栈的深度是所有方法中，最大的操作数。
    - 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，栈帧持有这个引用是为了支持方法调用过程中的动态连接，即，调用一个方法是通过该引用找到运行时常量池中的方法信息的。
    - 方法返回地址：方法执行结束，不管是正常退出还是异常退出，都需要返回到该方法被调用的位置。
3. 本地方法栈（Native Method Stack）：与Java虚拟机栈类似，但是用于执行本地方法（Native Method）。
4. Java堆（Java Heap）：用于存储对象实例、数组等信息，是所有线程共享的内存区域。
5. 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在Java8之前，HotSpot虚拟机将方法区实现为永久代，能够通过分代收集的GC来管理其内存区域。但这种设计导致Java应用经常遇到内存溢出问题，很多JVM都需要在启动时添加参数-XX:MaxPermSize来调整永久代的大小。因此在Java7的时候，就先将方法区中的字符串常量池、静态变量等转移到了Java堆中；而到了Java8，就直接移除了永久代，将其中剩下的内容如类的元信息、方法元信息、class常量池(字面量和符号引用)、运行时常量池(在运行期间会导入class常量池等地方的内容)等移动到了一个新的区域Metaspace元数据区，将JIT即时编译的代码缓存放到了CodeCache区域。

## JDK1.8里面，为什么使用元空间替代永久代作为方法区的实现
1. 永久代的大小无法动态调整，可能会出现OOM。元空间使用本地内存，容量可以根据初始容量、最大容量、闲置最小比例、闲置最大比例来动态调整元空间大小。
2. 永久的的垃圾回收基于标记清除算法，垃圾回收过程非常复杂，可能会频繁Full GC。元空间垃圾回收时，可以使用 G1 GC 算法进行优化，因为 G1 算法已经被用于管理堆内存，因此使用相同的算法来管理元空间更高效。

##  Java堆具体是怎么分区的
1. 年轻代：分为一个Eden区和两个Survivor区，默认比例大致是8:1:1。大部分新对象都会被分配到Eden区。当Eden区满时，这些对象中的一部分会被移动到Survivor区（其中一个为From区，一个为To区），这些对象经过一段时间后如果仍然存活，则会被移动到老年代中。
2. 老年代：存储一些年龄比较大的对象，这些对象由于生命周期比较长，不容易被垃圾回收器回收。

## 如何判断对象是否存活
1. 引用计数算法：在对象中添加一个引用计数器；每当被引用时，计数器就加1；每当失去一个引用时，计数器就减1；只要计数器为零，该对象就不能再被使用。虽然思路简单，但实现起来有很多例外场景，需要很多额外处理。比如对象之间的循环引用。
2. 可达性分析算法：从一些被称为GC Roots的根对象出发，根据引用关系向下推导可以到达的对象，形成引用链。如果某个对象与GC Roots之间没有任何引用链相连，就认为从GC Roots到该对象是不可达的。不可达的对象即不可能再被使用，是可以被回收的对象。可达性分析算法可以轻松解决循环引用的问题。

## Young GC和Full GC分别什么情况下触发
### Young GC 触发的情况：
1. Eden 区域内存不足时，会触发 Young GC 进行内存清理，通常会把 Eden 区中存活的对象复制到 Survivor 区中。
2. Survivor 区内存不足时，也会触发 Young GC。当其中一个 Survivor 区被占满时，触发 Young GC，并把存活的对象复制到另一个Survivor区。目的是回收内存碎片。
### Full GC触发的情况：
1. Old 区空间不足，无法为新对象分配内存，此时会进行 Full GC。
2. 过多的空间碎片导致系统无法找到足够的连续内存空间，从而触发 Full GC 进行内存整理和回收。

## Java 中可以作为GC Roots的对象有哪几种
有些对象被视为 GC Roots，因为它们无法通过其他对象到达。垃圾回收器从这些对象开始跟踪并标记所有可达对象，剩下的就是无法访问的对象，即垃圾，然后清理并回收它们的空间。  
1. 虚拟机栈中，栈帧中的方法参数、局部变量的引用对象。
2. 本地方法栈中，JNI引用的对象。
3. 方法区中的静态变量和常量引用对象。
4. 其他基本类型（integer，long，float，double等）和系统类对象，如系统类加载器，方法集等。

## 什么是Stop The World
“Stop The World”（STW）是一个垃圾回收器的行为概念，即在垃圾回收器执行垃圾回收操作期间暂停了应用程序所有的线程，以便进行垃圾回收操作。在这段时间内，应用程序无法进行任何操作，包括响应用户请求，导致应用程序出现暂停。  
这种行为通常出现在年轻代垃圾回收、Full GC以及CMS收集器的垃圾回收阶段。由于STW的存在，当应用需要进行大量垃圾回收操作时，应用的性能将会受到影响，因为应用程序需要等待垃圾回收器完成其操作，才能继续进行下一步操作。

## 对象什么时候会进入老年代
1. 对象在Eden和Survivor区经历了一定次数的垃圾回收后，会被移动到老年代，这个阈值默认是15。
2. 无法在新生代分配合适内存的大对象在创建的时候，就被放入老年代。

## 简述一下分代收集理论
分代收集理论建立在三个经验假设之上：
1. 弱分代假说：绝大多数对象都是朝生夕灭的，生命周期很短。
2. 强分代假说：熬过越多次垃圾收集过程(多次可达性分析均可达)的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说占比极小。  

前两个假说奠定了分代收集的理论基础：垃圾收集器应该将Java堆划分为不同的区域，并根据其年龄(对象熬过垃圾收集的次数)分配到不同的区域。这样对于比较年轻的区域，GC更加频繁，因为可以回收更多的内存空间；而对于较老的区域，因为难以消亡，GC频率就会较低。这种分代收集理论可以兼顾垃圾收集的时间开销和内存利用率。
但只有前两个假说会带来一个问题：当单独对一个区域比如新生代进行垃圾收集时，由于新生代的对象有可能被老年代的对象所引用，因此需要在GC Roots中添加所有老年代的对象。反过来一样，对老年代进行垃圾收集时，需要将新生代的对象加入GC Roots。毫无疑问的是，将关联区域的所有对象加入GC Roots会给垃圾收集带来很大的性能负担。因此又有了上面的第三个假说。根据第三个假说，跨代引用比较少，只用在新生代建立一个全局的数据集，将老年代划分为若干小块，标识哪些块上存在跨代引用；当新生代GC时，不用将老年代的所有对象都加入GC Roots，只需要将有跨代引用的块加入即可。当然，这种方法需要在对象引用关系创建或改变时同时维护这个全局数据集，增加了部分性能开销，但相比将整个老年代加入GC Roots进行可达性分析来说，还是很划算的。

##  简述一下部分收集和整堆收集
1. 部分收集：Partial GC，指仅对部分分代区域进行的垃圾收集，它又可以分为新生代收集，老年代收集和混合收集。
    - 新生代收集，Minor GC或Young GC，针对新生代的垃圾收集。
    - 老年代收集，Major GC或Old GC，针对老年代的垃圾收集。(Major GC 有时也指整堆收集Full GC。)
    - 混合收集，Mixed GC，目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
2. 整堆收集，Full GC，针对整个Java堆个方法区的垃圾收集。

## 垃圾收集算法有哪些
1. 标记-清除算法 (Mark-Sweep)：首先标记所有活动对象，然后清除未标记对象，存在碎片问题。
2. 复制算法 (Copying)：将内存分成两块，每次只使用其中一块，当使用完后，将还存活的对象复制到另一块内存中，然后清除整块内存，不存在碎片问题，但需要额外的空间来复制对象。主要针对新生代存活的对象属于少数，因此标记-复制的就少，同时复制的时候也顺便清理了内存碎片
3. 标记-压缩算法 (Mark-Compact)：标记所有活动对象，然后将它们移到内存的一端，然后清除端之外的所有对象，现代JVM的默认收集算法之一。
4. 分代收集算法 (Generational)：根据对象的年龄将堆划分为不同的区域，一般是年轻代和老年代，两个区域使用不同的垃圾收集算法，适应不同对象的生命周期特点。常用的有Parallel Scavenge算法和CMS算法。

## 垃圾收集器有哪些，适用于什么场景
1. Serial收集器：Serial收集器采用标记复制算法对新生代进行垃圾收集。Serial收集器是最基础的收集器，虽然简单且STW时间相对较长，但在单核或内存受限的环境下，反而是很高效的一个垃圾收集器。例如一个只分配了单核CPU和较小内存(1G以内)的虚拟机上运行的客户端模式的JVM，就很适合使用Serial收集器。
2. ParNew收集器：ParNew就是Serial的GC多线程并行版本。G1成熟之前，主流的Java服务都会采用ParNew + CMS组合作为垃圾收集策略。之所以新生代用ParNew其实是由于实现框架的原因，目前只有ParNew能和CMS配合使用。如果老年代不使用CMS的话，那就也不会使用ParNew作为新生代垃圾收集器。但在CPU单核场景下，由于线程切换，性能就不如Serial收集器了。
3. Parallel Scavenge：新生代收集器，与ParNew在执行时基本相同，同样是基于标记复制算法实现，同样是并行收集。它与ParNew的不同之处在于：能够通过参数控制JVM吞吐量；具备自适应调节策略，把内存管理的调优任务交给虚拟机自己完成；由于底层框架不同的原因，导致不能和CMS配合使用。
4. Serial Old：是Serial收集器的老年代版本，采用标记整理算法，同样是单线程收集。
5. CMS收集器：是JVM中最初采用的一种并发垃圾收集器，采用了标记-清除算法，主要对老年代进行垃圾回收，目标明确、收集范围小，并且不整理内存空间，因此收集时间较短。但是由于内存碎片较多，使得JVM的内存分配变得复杂，会降低吞吐量，因此适用于响应速度较高的低延迟、低卡顿应用场景。
6. Parallel Old：是Parallel Scavenge的老年代版本，支持GC多线程并行收集，基于标记整理算法，由于整理了内存碎片，会造成更多更久的STW，因此适用于高吞吐量的场景，不适用于低延迟、低卡顿的场景。在注重JVM吞吐量，后台运算较多而与用户交互较少的业务场景中，比较适合使用Parallel Scavenge + Parallel Old的组合
7. G1收集器：是一款以Region(区域)为最小内存回收单位的，逻辑上采用分代收集理论的垃圾收集器。

## 简单说一下CMS收集器的垃圾收集过程
1. 初始标记阶段：停止所有应用线程，执行短暂的暂停操作。在这个阶段，只标记与GC Roots相关的对象，完成后继续执行应用程序。GcRoots枚举带来的停顿是很短暂且固定的，不会随着Java堆内存容量的增加而上升。
2. 并发标记阶段：在应用程序继续运行的同时，开始对所有剩余对象进行标记。符合条件的对象标记完成，不符合条件的对象被放入回收集。引用链推导的耗时是不固定的，所以采用并发的方式进行，但并发标记可能会带来对象消失的问题。
3. 重新标记阶段：当并发标记阶段结束后，暂停应用程序，执行一次短暂的重新标记操作，以便标记在并发标记阶段期间新创建或修改的对象。
    - 增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。
    - 原始快照：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。
    - 原始快照可能会导致实际只被删除引用没有被其他黑色对象新增引用的对象保留下来，成为浮动垃圾，要等到下次GC时再做可达性分析时才会被标记为白色。而增量更新没有这样的问题，但增量更新的效率没有原始快照高。
4. 并发清除阶段：并发清除阶段开始时，将所有未被标记的对象（即垃圾）放入回收集，并在完成时释放相应的空间。此操作是与应用程序同时进行的。

## 有了CMS收集器，为什么还要引入G1收集器
1. 与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，意味着G1运作期间产生内存空间碎片要少得多，垃圾收集完成之后能提供更多规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次GC。
2. G1是通过停顿预测模型计算出来的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间，因此即使使用了标记整理算法，仍然能做到比CMS更少的STW。
3. G1垃圾收集器按回收价值动态确定回收集，使得老年代的回收更加高效。

## G1收集器的Region是什么概念，还存在年轻代和老年代的说法吗
在使用G1垃圾收集器时，仍然使用分代收集理论，但再也不是物理上将堆内存划分为连续分配的新生代和老年代，而是变成了逻辑上的、物理不连续的逻辑分代。但是，与传统的垃圾收集器（如CMS）不同的是，G1将堆空间划分为多个大小相等的区域（Region），每个区域都可能被定义为年轻代或老年代。当垃圾收集器运行时，G1会选择垃圾最多的区域进行垃圾回收，并将该区域中存活的对象复制到其他空闲区域中，以回收该区域的空间，而不是像传统的年轻代和老年代的垃圾收集器一样只对年轻代或老年代进行垃圾回收。因此，G1垃圾收集器被认为是一种基于区域的垃圾收集器，它仍然将堆空间逻辑上分为年轻代和老年代，但更注重区域之间垃圾分布的平衡。

## 几个常见的JVM配置参数
1. -Xms: 设置JVM的初始堆内存大小
2. -Xmx: 设置JVM的最大堆内存大小
3. -Xmn: 设置JVM的年轻代内存大小
4. -Xss: 设置JVM的线程栈大小



# 多线程
## 并发和并行有什么区别
1. 并发是指两个或多个线程在一段时间内不断地进行交替执行，在逻辑上是同时执行的状态，但在物理上不可能同时运行。
2. 并行是指在同一时刻，多个处理器或多核处理器场景下，多个线程会同时执行不同的任务。



# Spring
## Spring 用到了哪些设计模式
1. 工厂模式：使用工厂模式创建bean。
2. 单例模式：一个类仅有一个实例，Spring 创建 Bean 实例默认是单例的。
3. 适配器模式：SpringMVC中的适配器HandlerAdapter。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。
为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 HandlerAdapter 实现类，当请求过来，SpringMVC会调用getHandler()获取相应的Controller，然后获取该Controller对应的 HandlerAdapter，最后调用HandlerAdapter的handle()方法处理请求，实际上调用的是Controller的handleRequest()。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。
4. 代理模式：spring 的 aop 使用了动态代理，有两种方式JdkDynamicAopProxy和Cglib2AopProxy。
5. 观察者模式：spring 中 observer 模式常用的地方是 listener 的实现，如ApplicationListener。其中一个对象（称为主题）维护一系列依赖于它的对象（称为观察者），当主题状态发生更改时，它会通知和自动更新其所有观察者。
6. 模板模式： Spring 中 jdbcTemplate、hibernateTemplate 等，就使用到了模板模式。将大部分操作封装在抽象模板中，并在具体模板类中实现了具体的操作步骤，而只需要传入一些具体的信息，比如sql。

## 什么是IOC，什么是DI
1. IOC：控制反转，由Spring容器管理bean的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类之间的耦合度。
2. DI：将一个对象需要的外部依赖关系通过参数或者属性注入的方式传递给这个对象，而不需要自行创建依赖对象。实现了类与类之间的解耦。

## IOC的实现机制是什么
1. 注解驱动方式：开发者在类或者属性上使用注解标识需要依赖注入的类或属性。当应用程序启动时，IOC 容器会扫描应用程序中所有注解，并根据注解信息自动创建依赖对象，并将依赖对象注入到需要依赖的类或属性中。
2. XML配置方式：开发者在配置文件中声明依赖关系，将依赖对象与被依赖对象的创建和组装过程完全交给 IOC 容器。当应用程序启动时，IOC 容器会从配置文件中读取依赖信息，自动创建依赖对象，并将依赖对象注入到需要依赖的类或属性中。

## BeanFactory和FactoryBean的区别
1. BeanFactory：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。
2. FactoryBean：通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，直接用xml配置比较麻烦，这时可以考虑用FactoryBean，可以隐藏实例化复杂Bean的细节。

## Spring 的单例 Bean 是否有线程安全问题
当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，如果业务逻辑有对单例状态的修改（体现为此单例的成员属性），则必须考虑线程安全问题。  
若每个线程中对全局变量、静态变量只有读操作，而无写操作，那么不会有线程安全问题；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。  
在Spring中无状态的Bean适合用单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，一般用Prototype模式或者使用ThreadLocal解决线程安全问题。

## Spring怎么解决循环依赖的问题
- 构造器注入的循环依赖：Spring处理不了，直接抛出异常。
- 单例模式下属性注入的循环依赖：通过三级缓存处理循环依赖。
- 非单例循环依赖：无法处理。

Spring为了解决单例的循环依赖问题，使用了三级缓存：  
singletonObjects：完成了初始化的单例对象map，bean name --> bean instance  
earlySingletonObjects：完成实例化未初始化的单例对象map，bean name --> bean instance  
singletonFactories： 单例对象工厂map，bean name --> ObjectFactory，单例对象实例化完成之后会加入singletonFactories。  
假如A依赖了B的实例对象，同时B也依赖A的实例对象。  
1. A首先完成了实例化，并且将自己添加到singletonFactories中。
2. 接着进行依赖注入，发现自己依赖对象B，此时就尝试去get(B)。
3. 发现B还没有被实例化，对B进行实例化。
4. B在初始化的时候发现自己依赖了对象A，于是尝试get(A)。尝试一级缓存singletonObjects和二级缓存earlySingletonObjects没找到，尝试三级缓存singletonFactories，由于A初始化时将自己添加到了singletonFactories，所以B可以拿到A对象，然后将A从三级缓存中移到二级缓存中。
5. B拿到A对象后顺利完成了初始化，然后将自己放入到一级缓存singletonObjects中。
6. 此时返回A中，A此时能拿到B的对象顺利完成自己的初始化。

由此看出，属性注入的循环依赖主要是通过将实例化完成的bean添加到singletonFactories来实现的。而使用构造器依赖注入的bean在实例化的时候会进行依赖注入，不会被添加到singletonFactories中。比如A和B都是通过构造器依赖注入，A在调用构造器进行实例化的时候，发现自己依赖B，B没有被实例化，就会对B进行实例化，此时A未实例化完成，不会被添加到singletonFactories。而B依赖于A，B会去三级缓存寻找A对象，发现不存在，于是又会实例化A，A实例化了两次，从而导致抛异常。  
总结：1、利用缓存识别已经遍历过的节点； 2、利用Java引用，先提前设置对象地址，后完善对象。

## @Autowired和@Resource的区别，@Qualifier注解有什么作用
1. @Autowired注解是按照类型（byType）装配依赖对象的,但是存在多个类型⼀致的bean，⽆法通过byType注⼊时，就会再使⽤byName来注⼊，如果还是⽆法判断注⼊哪个bean则会UnsatisfiedDependencyException。
2. @Resource会⾸先按照byName来装配，如果找不到bean，会⾃动byType再找⼀次。
3. 当需要创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个 bean 来消除歧义。

## 什么是AOP
面向切面编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。


## Spring AOP和AspectJ AOP的区别
1. Spring AOP仅支持方法级别的切面，而AspectJ AOP支持更广泛的切面，包括类级别切面、对象级别切面等。
2. Spring AOP使用基于代理的AOP实现，而AspectJ AOP使用基于字节码的AOP实现。
3. Spring AOP只支持Spring管理的bean，而AspectJ AOP支持所有Java对象。
4. AspectJ AOP可以在编译时、类加载时或运行时织入切面，而Spring AOP仅支持运行时织入切面。

## JDK动态代理和CGLIB代理的区别
1. JDK动态代理：  
    使用反射技术实现。如果目标类实现了接口，Spring AOP会选择使用JDK动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。缺点时，目标类必须有实现的接口。如果某个类没有实现接口，那么这个类就不能用JDK动态代理。
2. CGLIB动态代理：
   使用字节码增强技术来实现，需要引入相关依赖 asm.jar 。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。
3. JDK代理在生成代理对象时，需要消耗额外的时间。因为它不仅要生成代理类，还要在运行时动态生成接口的实现类。而CGLIB代理可以直接继承被代理类生成代理对象，因此在生成代理对象时不需要消耗额外的时间。

## Spring事务的隔离级别
1. DEFAULT：使用数据库默认的隔离级别。
2. READ_UNCOMMITTED：最低的隔离级别。在这个隔离级别下，一个事务可以读取另一个事务未提交的数据。但是，由于可能读取到未提交的数据，因此会存在脏读，不可重复读和幻读。
3. READ_COMMITTED：这个隔离级别下，一个事务只能读取另一个事务已经提交的数据。这种隔离级别可以避免脏读问题，但会存在不可重复读和幻读问题。
4. REPEATABLE_READ：保证一个事务不会读取另一个事务修改但未提交的数据。这种隔离级别可以避免脏读和不可重复读问题，但会存在幻读问题。
5. SERIALIZABLE：最高的隔离级别，它通过强制事务串行执行来避免幻读问题。在这种隔离级别下，所有事务会按照顺序一个一个执行，因此会牺牲性能。

## 声明式事务的实现原理
声明式事务是指将事务的定义和实现与业务逻辑代码完全分离，通过配置的方式来实现事务管理，使得业务逻辑代码与事务管理代码解耦。Spring 中实现声明式事务的方式是基于 AOP。当某一个方法被声明为事务方法时，Spring 会自动为这个方法创建一个事务增强，并将其注入到容器中进行管理，在执行这个被拦截的方法时，事务增强会在方法执行前开启事务，在方法执行后提交事务。如果方法执行出现异常，事务增强会回滚事务，以保证数据的一致性。

## 声明式事务在哪些情况下会失效
1. 方法没有被正确地注解：声明式事务只有在方法上正确地使用了@Transactional 注解时才会生效。如果方法没有被正确地注解，事务将不会起作用。
2. 异常没有被正确处理：如果在Transactional注解所注解的方法中抛出了未被捕获的异常，则事务将失败，所有操作都将被回滚。但是如果异常被捕获并在方法中处理，则事务将会提交。
3. 数据库不支持事务：有些轻量级数据库，如H2和HSQLDB，可能没有完全实现JTA规范，因此声明式事务可能会失效。
4. 方法调用不经过代理：如果方法的调用不经过代理对象，则@Transactional注解将不起作用。这种情况可能出现在对象自调用，即在同一对象中调用另一个方法。
5. 并发问题：当多个事务同时访问共享数据时，可能会出现并发问题。这可能导致事务失败或导致数据不一致。为了避免这些问题，应该在事务中使用悲观锁或乐观锁。



# 数据结构
## 谈谈满二叉树、完全二叉树、二叉查找树、平衡二叉树和红黑树
1. 满二叉树：二叉树的每一层的几点都达到最大值。
2. 完全二叉树：完全二叉树由满二叉树转化而来，也就是将满二叉树从最后一个节点开始删除，一个一个从后往前删除，剩下的就是完全二叉树。
3. 二叉查找树：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大。
4. 平衡二叉树：基于二叉查找树，左右子树的高度之差不大于 1。
5. 红黑树：红黑树有四条性质  
    a. 节点是红色或黑色。  
    b. 根节点是黑色。 
    c. 所有的叶子节点（NIL节点）都是黑色。  
    d. 每个红色节点的两个子节点都是黑色。  
    e. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## 平衡二叉树和红黑树的区别
1. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

## 谈谈红黑树的实现
红黑树的插入：  
1. 将新插入的节点 X 标记为红色
2. 如果 X 是根结点(root)，则标记为黑色
3. 如果 X 的 parent 不是黑色，同时 X 也不是 root  
    - 3.1 如果 X 的 uncle (叔叔) 是红色  
        - 3.1.1 将 parent 和 uncle 标记为黑色  
        - 3.1.2 将 grand parent (祖父) 标记为红色  
        - 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3  
    - 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理  
        - 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) => 旋转 -> 变色  
        - 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) => 旋转 -> 旋转 -> 变色  
        - 3.2.3 右右 (和 3.2.1 镜像过来，恰好相反) => 旋转 -> 变色  
        - 3.2.4 右左 (和 3.2.2 镜像过来，恰好相反) => 旋转 -> 旋转 -> 变色  



# 数据库
## undolog redolog binlog分别是什么
Mysql分为Server层和引擎层。
1. redo log：  
    redo log是执行引擎Innodb的日志，记录了磁盘上的某个位置，应该做什么样的修改。  
    如果每个update语句都要去操作磁盘，那么整个过程的IO成本、查找成本会很高。因此先更新内存，并写入redo log，并在适当的时候再更新磁盘。  
    redo log是有大小限制的，如果redo log满了，需要等待记录擦除后才能再进行更新操作。  
    redo log提供了故障恢复能力，redo log的prepare-commit两段提交，保证了和bin log的一致性。  
2. bin log：  
    bin log是Server成的日志，记录了原始的sql语句。  
3. undo log：  
    用于记录修改前的值，可以用undo log对数据进行回滚。

## Mysql隔离级别
1. Read Uncommitted（读取未提交内容）
2. Read Committed（读取提交内容）
3. Repeatable Read（可重读）
4. Serializable（序列化）

## 什么是脏读、不可重复度、幻读
1. 脏读  
    能在事务中读取到另一个事务的未提交内容。
2. 不可重复读  
   能在事务中两次读取的数据不一致。
3. 幻读
   能在事务中两次读取的行数不一致。  
   如事务A对一个表的数据全量更新，然后事务B插入一条数据，然后A再次读取时，发现还有数据未更新，宛如产生幻觉一样。  
   innodb在范围条件加锁时，会使用间隙锁防止幻读

## 表锁、行锁、页锁的区别
1. 表级锁  
    开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2. 行级锁  
   InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
   开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3. 页级锁  
   开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## innodb中，3层的B+树能存多少行数据
假设1行数据1k，主键索引(int)8byte，指针6byte  
````
一页16k  
一页最多16*1024/(8+6)=1170条索引  
一页最多16行数据  
3层B+树存 1170*1170*16=21,902,400行数据
````  

## 数据库为什么使用B+数不使用B树
1. 更高的查询效率  
    B+ 树的所有数据都存储在叶子节点中，非叶子节点只存储键值。而且，所有的叶子节点都按照键值顺序链接在一起，可以方便地搜索、遍历和排序。相比之下，B 树每个节点中都存储数据，因此需要经常进行磁盘 I/O 操作，效率相对较低。
2. 更高的数据密度  
   B+ 树非叶子节点只存储键值，而不是所有的数据项，因此一个节点能存储更多的键值，减少了索引占用的磁盘空间，提高了索引的数据密度。
3. 适合范围查询
   由于 B+ 树的所有叶子节点都按键值顺序链接在一起，因此范围查询效率非常高。而 B 树节点中的数据并非都按照顺序存储，无法快速定位范围查询的起始和结束位置。
4. 适合索引顺序扫描  
   B+ 树的叶子节点按顺序链接在一起，因此适合索引顺序扫描，可以提高对索引的利用率。相反，B 树无法很好地支持索引顺序扫描操作。

因此，B+ 树更适合数据库领域的索引结构，也更能够满足数据库索引的需求。

## 什么是乐观锁，什么是悲观锁
1. 乐观锁：假设多个事务访问同一共享资源时，每个事务都假设自己能够成功地进行操作，不会有其他事务跟自己产生冲突。在更新时，每个事务都会首先读取当前的数据版本号或时间戳，然后进行操作，最后再次检查版本号或时间戳是否变化，如果没有变化，就表示操作成功，否则操作失败。乐观锁需要用到版本号或时间戳等机制来判断是否更改被其他事务修改过。
2. 悲观锁：假设多个事务访问同一共享资源时，每个事务都假设其他事务可能会与自己产生冲突，因此会将共享资源锁定，直到自己完成操作后才释放锁。悲观锁需要把共享资源锁住，如果其他事务也想要访问共享资源，在悲观锁的机制下，其他事务需要等待锁被释放后才能访问该资源。悲观锁分为共享锁和排他锁。
````
使用 SELECT ... LOCK IN SHARE MODE 添加共享锁
使用 SELECT ... FOR UPDATE 添加排他锁
````



# C++
## 什么是虚函数，什么是纯虚函数
1. 基类定义一个虚函数，是为了能在子类重写了这个函数之后，能够调用子类的这个函数，实现多态。
2. 定义一个函数为纯虚函数，代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
3. 含有一个或多个纯虚函数的类是抽象类，不能实例化。



# 参考链接
https://zhuanlan.zhihu.com/p/351241768 JVM后序继续梳理
